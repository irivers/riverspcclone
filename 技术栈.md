# 技术栈

> 记录一些技术思路，有利于梳理清整个行业都在做什么，应该做什么

## Schedule
- 第一章节：7+8+7=22个专题
- 第二章节：6+8+10+6=30个专题
- 第三章节：3+6+4+4=17个专题
- 一天准备一个专题，也需要整整一个Q才能完成，任务量还是相当艰巨的
## September

| Sun  | Mon  | Tue  | Wed  | Thu  | Fri  | Sat  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |  24  |  25  |  26  |  27  |  28  |  29  |
|  30  |      |      |      |      |      |      |

- [ ] 9月26日：Proxy代理模式
  - [ ] 实际9月26日并没有完全完成，回去之后，只完成了一部分
  - [ ] 9月27日，继续完善，同时把懒加载的部分也填充进去（这部分想错了，之前需要注意的是单例模式）
- [ ] 9月28日：Factory工厂模式
- [ ] 9月27日：Singleton单例模式
  - [ ] 把工作调整一下，看一下单例模式的具体实现
  - [ ] 差一些没有完成，已经完成的部分消化一下，还是很有内容的
- [ ] 9月29日：Delegate委派模式
- [ ] 9月30日：Strategy策略模式

## October

| Sun  | Mon  | Tue  | Wed  | Thu  | Fri  |
| :--: | :--: | :--: | :--: | :--: | :--: |
|      |  1   |  2   |  3   |  4   |  5   |
|  7   |  8   |  9   |  10  |  11  | 12   |
|  14  |  15  |  16  |  17  |  18  |  19  |
|  21  |  22  |  23  |  24  |  25  |  26  |
|  28  |  29  |  30  |  31  |      |      |

- [ ] 10月1日
- [ ] 10月2日
- [ ] 10月3日
- [ ] 10月4日
- [ ] 10月5日
- [ ] 10月6日
- [ ] 10月7日
- [ ] 10月第一周成果小结


## 0.工程化-Git

> 工欲善其事必先利其器，让自己有更多的时间来思考

#### 0.0 Git与GitHub结合
- 配置Git
	```shell
	git config --global user.name "RiversYung"
	git config --global user.email "RiversYung@gmail.com"
	```
- 配置SSH
	```shell
		ssh-keygen -t rsa -C "RiversYung@gmail.com"    	
  ```
    - 将生成的`id_rsa.pub`内容复制到github ssh keys里面
- 克隆仓库
	```GIT
	git clone https://github.com/riversyung/riverspcclone.git
  ```
- 上传项目
	```git
	git add .
	git commit -m "commit comments"
	git push -u origin master
	```

#### 0.1 Git的工作原理
#### 0.2 Git常用命令
#### 0.3 Git冲突怎么引起的，如何解决
#### 0.4 Git Flow规范团队Git使用规程

## 1. 源码分析专题
> 源码中的经典设计思想，提升技术审美、提高核心竞争力

### 1. 1常用设计模式
#### 1.1.1 Proxy代理模式

##### 模式概述与类图
![img](https://pic4.zhimg.com/80/v2-6f99360762e356f28fea3a4cb69d9406_hd.jpg)

代理模式中的三种角色：
 - 抽象代理：声明真实对象和代理对象的共同接口
 -  代理角色：1. 内部含有真实对象的引用，从而可以操作真实对象； 2. 代理对象提供与真实对象相同的接口，以便在任何时刻都能替代真实对象；3. 代理对象可以在执行真实对象的操作时，附加其他的操作，相当于对真实对象进行封装
 - 真实角色：代理角色所代表的真实对象，是最终要引用的对象

	- Main:按照上面的类图，应该还有一个客户端，使用真实角色和抽象代理完成一些工作

##### 模式意义
- 对外部提供统一的接口方法，而代理类在接口中实现对真实类的附加操作行为，从而可以在不影响外部调用情况下，进行系统扩展
- 代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问
- 因为安全原因需要屏蔽客户端直接访问真实对象
- 在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)
- 为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的
##### 示例代码

1. 延迟加载的示例代码：假设DBQuery是进行数据库操作，DBQueryProxy是DBQuery的代理类

   ```java
   //抽象代理
   public interface IDBQuery{
       String request();
   }
   //真实角色
   public class DBQuery implements IDBQuery{
       public DBQuery(){
           Thread.sleep(1000);//假设数据库连接等耗时操作
       }
       @Override
       public String request(){
           return "request string";
       }
   }
   //代理角色
   public class DBQueryProxy implements IDBQuery{
       private DBQuery real = null;
       
       @Override
       public String request(){
           if(real == null){
               real = new DBQuery();
           }
           return real.request();
       }
   }
   public class Main{
       public static void main(String[] args){
           IDBQuery q = new DBQueryProxy();//使用代理
           q.request();//在真正使用时才创建真实对象
       }
   }
   ```

   实际并没有看明白懒加载的实现机理，现在回过头再看一下，就明白要表达什么意思了。采用DBQueryProxy，new创建对象的时候，只会调用其无参构造方法，不会涉及到DBQuery真实对象的创建，这样的话，就可以在真正调用的时候，再实例化对象

##### 使用场景
- 延迟加载
  - 延迟加载的核心思想：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它原有的位置，只有在真正需要的时候才对它进行加载
  - 延迟加载的意义：
    - 1. 可以在时间轴上分散系统压力
      2. 对于很对真实角色来说，在软件启动到关闭的整个过程，可能根本不会被调用，初始化这些数据无疑是一种资源浪费
##### 代理模式分类

- 动态代理

- 静态代理

#### 其他引申
在延迟加载的基础之上，引申一下

#### 1.1.2 Factory工厂模式
#### 1.1.3 Singleton单例模式

##### 关注核心
- 对象创建次数以及何时被创建
	- DCL双锁检测(double checked locking)
	- 多个类加载器(classLoader)协同
	- 跨JVM(集群、远程EJB等)
	- 单例对象被销毁后重建等
##### 懒汉模式
- 缺点：没有考虑线程安全，可能会产生多个实例

- 优点：很好地表达单例模式的思想，保持只有一个实例；相比饿汉模式，实现了延迟加载

- 实现是通过静态常量实现

  ```java
  public class Singleton{
      private static Singleton instance == null;
      private Singleton(){}
      public static Singleton getInstance(){
          if(instance == null){
              instance = new Singleton();
          }
          return instance;
      }
  }
  // 这仅仅是一个示例，创建一个对象，也不做什么事情，真实情况里面会涉及到变量，方法等内容
  // 如果想保证方法在多线程情况下安全，最简单的方式，就是加上synchronize关键字
  ```

##### 饿汉模式

- 缺点：可能会产生很多无用的实例

- 优点（可用线程安全）：JVM加载类的时候，是单线程的，可以保证只存在单一实例

  - 对于上面所说的优点，持保留意见，没有真正理解
  - 是不是利用了静态对象的特点？并没有，使用static也仅是为了方便提供一个全局的访问点，同时外部也没有可以new的方法使用了

  ```java
  public class Singleton{
      private static Singleton instance = new Singleton();
      private Singleton(){}
      
      public static Singleton getInstance(){
          return instance;
      }
  }
  ```


##### 双重校验锁

- 双重校验锁的核心就是保证线程安全，同时要轻量

- 使synchronize的作用范围缩小

  ```java
  //在懒汉模式之上，保证线程安全，有如下几种演变方式
  //这是最质朴实现方式
  public static Singleton getInstance(){}
  //这是保证线程安全后的处理方式
  public synchronized static Singleton getInstance(){}
  //想缩小锁的范围，变成如下的形式
  public static Singleton getInstance(){
      if(instance == null){
          synchronized(Singleton.class){//这里可以缩小锁的范围，只有在instance==null的情况下才锁，避免了很多Synchronize的执行情况
              if(instance ==null){	//这里是双重的地方。再次对null进行判断
                  instance = new Singleton();
              }
          }
      }
      return instance;
  }
  ```

- 看似上面的代码可以解决问题了，实际上又引入了新的问题。在JKD1.5之后，Java编译器允许处理器乱序执行（out-of-order），`instance = new Singleton()`因此上面的代码主要分为三步：1. 给Singleton的实例分配内存；2. 初始化Singleton的构造器； 3. 将instance对象指向分配的内存空间（此时instance不为null）

- 如果按照上面的思路，1-3-2的顺序执行，在执行3完毕之后，instance已经非空了，线程2直接拿走instance然后使用，这样的话，出错后，单步追踪也很难重现错误。改进思路就是使用volatile关键字

- volatile关键字的两个特性：

  - 保证了不同线程对该变量操作的内存可见性
  - 禁止指令重排序

- Volatile 底层实现原理：将volatile关键字代码生成汇编语言，会发现加入volatile关键字的代码会多出一个lock前缀指令。lock前缀指令相当于一个内存屏障，内存屏障提供一下功能：

  - 重排序时不能把后面的指令重排序到内存屏障之前的位置
  - 使得本CPU的Cache写入内存
  - 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见

- 最终完整版代码

  ```java
  public class Singleton{
      private volatile static Singleton instance = null;
      private Singleton(){}
      
      public static Singleton getInstance(){
          if(instance == null){
              synchronized(Singleton.class){
                  if(instance == null){
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```


##### 静态内部类



##### 枚举

#### 1.1.4 Delegate委派模式
#### 1.1.5 Strategy策略模式
#### 1.1.6 Prototype原型模式
#### 1.1.7 Template模板模式

### 1.2 Spring
#### 1.2.1 IOC容器设计原理及高级特性
#### 1.2.2 AOP设计原理
#### 1.2.3 FactoryBean与BeanFactory
#### 1.2.4 Spring事务处理机制
#### 1.2.5 基于SpringJDBC手写ORM框架
#### 1.2.6 SpringMVC九大组件
#### 1.2.7 手写实现SpingMVC框架
#### 1.2.8 Spring5新特性

### 1.3 Mybatis
#### 1.3.1 代码自动生成器
#### 1.3.2 MyBatis关联查询、嵌套查询
#### 1.3.3 缓存使用场景及选择策略
#### 1.3.4 Spring集成下的SqlSession与Mapper 
#### 1.3.5 MyBatis的事务
#### 1.3.6 分析MyBatis的动态代理的真正实现
#### 1.3.7 手动实现Mini版的MyBatis

## 2.分布式专题
> 迎接高并发大数据的挑战。从深度到广度完善知识体系

### 2.1 分布式架构原理
#### 2.1.1 分布式架构演进过程
#### 2.1.2 如何把应用从单机扩展到分布式
#### 2.1.3 CDN加速静态文件访问
#### 2.1.4 系统监控容灾、存储动态扩展
#### 2.1.5 架构设计及业务驱动划分
#### 2.1.6 CAP、Base理论及其应用

### 2.2 分布式架构策略
#### 2.2.1 分布式架构网络通信原理剖析
#### 2.2.2 通信协议中的序列化和反序列化
#### 2.2.3 基于框架的RPC技术WebService/RMI/Hession
#### 2.2.4 深入分析Zookeeper在disconf配置中心的应用
#### 2.2.5 深入分析Zookeeper Zab协议及选举机制源码
#### 2.2.6 Dubbo管理中心及监控平台安装部署
#### 2.2.7 基于Dubbo的分布式系统架构实战
#### 2.2.8 Dubbo容错机制及高扩展性分析

### 2.3 分布式架构中间件
#### 2.3.1 分布式消息通信ActiveMQ/Kafka/RabbitMQ
#### 2.3.2 Redis主从复制原理及无磁盘复制分析
#### 2.3.3 图解Redis中APF和RDB持久化策略的原理
#### 2.3.4 MongoDB企业级集群解决方案
#### 2.3.5 MongoDB数据分片、转存及恢复策略
#### 2.3.6 基于OpenResty部署应用层Nginx以及Nginx+luo实战
#### 2.3.7 Nginx反向代理服务器及负载均衡服务配置实战
#### 2.3.8 基于Netty实现高性能IM聊天
#### 2.3.9 基于Netty实现Dubbo多协议通信支持
#### 2.3.10 Netty无锁化串行设计及高并发处理机制

### 2.4 分布式架构实战
#### 2.4.1 分布式全局ID生成方案
#### 2.4.2 Session跨域共享及企业级单点登录解决方案实战
#### 2.4.3 分布式事务解决方案实战
#### 2.4.4 高并发下的服务降级、限流实战
#### 2.4.5 基于分布式架构下分布式锁的解决方案实战
#### 2.4.6 分布式架构下实现分布式定时调度

## 3. 性能优化
> 从JVM底层原理到内存优化，再到中间件的性能调优

### 3.1 理解性能优化
#### 3.1.1 性能基准
#### 3.1.2 性能优化到底是什么
#### 3.1.3 衡量维度

### 3.2 JVM调优
#### 3.2.1 JVM运行时数据区
#### 3.2.2 JVM内存模型 JMM
#### 3.2.3 GC可达
#### 3.2.4 各垃圾回收器使用场景(Throughput\CMS)
#### 3.2.5 GC日志，从日志看端倪
#### 3.2.6 实战MAT分析dump文件(推理、验证)

### 3.3 Tomcat调优
#### 3.3.1 Tomcat运行机制及框架
#### 3.3.2 分析Tomcat线程模型
#### 3.3.3 Tomcat系统参数认识及调优
#### 3.3.4 基准测试

### 3.4 MySQL调优
> TianZhen 20180911技术分享《统一监控平台架构和实践》，有涉及到SQL调优

#### 3.4.1 MySQL底层B+ Tree机制
#### 3.4.2 SQL执行计划详解
#### 3.4.3 索引优化详解
#### 3.4.4 SQL语句优化











