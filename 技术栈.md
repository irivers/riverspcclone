# 技术栈

> 记录一些技术思路，有利于梳理清整个行业都在做什么，应该做什么

## Schedule
- 第一章节：7+8+7=22个专题
- 第二章节：6+8+10+6=30个专题
- 第三章节：3+6+4+4=17个专题
- 一天准备一个专题，也需要整整一个Q才能完成，任务量还是相当艰巨的
## September

| Sun  | Mon  | Tue  | Wed  | Thu  | Fri  | Sat  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |  24  |  25  |  26  |  27  |  28  |  29  |
|  30  |      |      |      |      |      |      |

- [ ] 9月26日：Proxy代理模式
- [ ] 9月27日：Factory工厂模式
- [ ] 9月28日：Singleton单例模式
- [ ] 9月29日：Delegate委派模式
- [ ] 9月30日：Strategy策略模式

## October

| Sun  | Mon  | Tue  | Wed  | Thu  | Fri  |
| :--: | :--: | :--: | :--: | :--: | :--: |
|      |  1   |  2   |  3   |  4   |  5   |
|  7   |  8   |  9   |  10  |  11  | 12   |
|  14  |  15  |  16  |  17  |  18  |  19  |
|  21  |  22  |  23  |  24  |  25  |  26  |
|  28  |  29  |  30  |  31  |      |      |

- [ ] 10月1日
- [ ] 10月2日
- [ ] 10月3日
- [ ] 10月4日
- [ ] 10月5日
- [ ] 10月6日
- [ ] 10月7日
- [ ] 10月第一周成果小结


## 0.工程化-Git

> 工欲善其事必先利其器，让自己有更多的时间来思考

#### 0.0 Git与GitHub结合
- 配置Git
	```shell
	git config --global user.name "RiversYung"
	git config --global user.email "RiversYung@gmail.com"
	```
- 配置SSH
	```shell
		ssh-keygen -t rsa -C "RiversYung@gmail.com"    	
  ```
    - 将生成的`id_rsa.pub`内容复制到github ssh keys里面
- 克隆仓库
	```GIT
	git clone https://github.com/riversyung/riverspcclone.git
  ```
- 上传项目
	```git
	git add .
	git commit -m "commit comments"
	git push -u origin master
	```

#### 0.1 Git的工作原理
#### 0.2 Git常用命令
#### 0.3 Git冲突怎么引起的，如何解决
#### 0.4 Git Flow规范团队Git使用规程

## 1. 源码分析专题
> 源码中的经典设计思想，提升技术审美、提高核心竞争力

### 1. 1常用设计模式
#### 1.1.1 Proxy代理模式

##### 模式概述与类图
![img](https://pic4.zhimg.com/80/v2-6f99360762e356f28fea3a4cb69d9406_hd.jpg)

代理模式中的三种角色：
 - 抽象代理：声明真实对象和代理对象的共同接口
 -  代理角色：1. 内部含有真实对象的引用，从而可以操作真实对象； 2. 代理对象提供与真实对象相同的接口，以便在任何时刻都能替代真实对象；3. 代理对象可以在执行真实对象的操作时，附加其他的操作，相当于对真实对象进行封装
 - 真实角色：代理角色所代表的真实对象，是最终要引用的对象

	- Main:按照上面的类图，应该还有一个客户端，使用真实角色和抽象代理完成一些工作

##### 模式意义
- 对外部提供统一的接口方法，而代理类在接口中实现对真实类的附加操作行为，从而可以在不影响外部调用情况下，进行系统扩展
- 代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问
- 因为安全原因需要屏蔽客户端直接访问真实对象
- 在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)
- 为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的
##### 示例代码

1. 延迟加载的示例代码：假设DBQuery是进行数据库操作，DBQueryProxy是DBQuery的代理类

   ```java
   //抽象代理
   public interface IDBQuery{
       String request();
   }
   //真实角色
   public class DBQuery implements IDBQuery{
       public DBQuery(){
           Thread.sleep(1000);//假设数据库连接等耗时操作
       }
       @Override
       public String request(){
           return "request string";
       }
   }
   //代理角色
   public class DBQueryProxy implements IDBQuery{
       private DBQuery real = null;
       
       @Over
   }
   ```


##### 使用场景
- 延迟加载
  - 延迟加载的核心思想：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它原有的位置，只有在真正需要的时候才对它进行加载
  - 延迟加载的意义：
    - 1. 可以在时间轴上分散系统压力
      2. 对于很对真实角色来说，在软件启动到关闭的整个过程，可能根本不会被调用，初始化这些数据无疑是一种资源浪费
##### 代理模式分类

#### 1.1.2 Factory工厂模式
#### 1.1.3 Singleton单例模式
#### 1.1.4 Delegate委派模式
#### 1.1.5 Strategy策略模式
#### 1.1.6 Prototype原型模式
#### 1.1.7 Template模板模式

### 1.2 Spring
#### 1.2.1 IOC容器设计原理及高级特性
#### 1.2.2 AOP设计原理
#### 1.2.3 FactoryBean与BeanFactory
#### 1.2.4 Spring事务处理机制
#### 1.2.5 基于SpringJDBC手写ORM框架
#### 1.2.6 SpringMVC九大组件
#### 1.2.7 手写实现SpingMVC框架
#### 1.2.8 Spring5新特性

### 1.3 Mybatis
#### 1.3.1 代码自动生成器
#### 1.3.2 MyBatis关联查询、嵌套查询
#### 1.3.3 缓存使用场景及选择策略
#### 1.3.4 Spring集成下的SqlSession与Mapper 
#### 1.3.5 MyBatis的事务
#### 1.3.6 分析MyBatis的动态代理的真正实现
#### 1.3.7 手动实现Mini版的MyBatis

## 2.分布式专题
> 迎接高并发大数据的挑战。从深度到广度完善知识体系

### 2.1 分布式架构原理
#### 2.1.1 分布式架构演进过程
#### 2.1.2 如何把应用从单机扩展到分布式
#### 2.1.3 CDN加速静态文件访问
#### 2.1.4 系统监控容灾、存储动态扩展
#### 2.1.5 架构设计及业务驱动划分
#### 2.1.6 CAP、Base理论及其应用

### 2.2 分布式架构策略
#### 2.2.1 分布式架构网络通信原理剖析
#### 2.2.2 通信协议中的序列化和反序列化
#### 2.2.3 基于框架的RPC技术WebService/RMI/Hession
#### 2.2.4 深入分析Zookeeper在disconf配置中心的应用
#### 2.2.5 深入分析Zookeeper Zab协议及选举机制源码
#### 2.2.6 Dubbo管理中心及监控平台安装部署
#### 2.2.7 基于Dubbo的分布式系统架构实战
#### 2.2.8 Dubbo容错机制及高扩展性分析

### 2.3 分布式架构中间件
#### 2.3.1 分布式消息通信ActiveMQ/Kafka/RabbitMQ
#### 2.3.2 Redis主从复制原理及无磁盘复制分析
#### 2.3.3 图解Redis中APF和RDB持久化策略的原理
#### 2.3.4 MongoDB企业级集群解决方案
#### 2.3.5 MongoDB数据分片、转存及恢复策略
#### 2.3.6 基于OpenResty部署应用层Nginx以及Nginx+luo实战
#### 2.3.7 Nginx反向代理服务器及负载均衡服务配置实战
#### 2.3.8 基于Netty实现高性能IM聊天
#### 2.3.9 基于Netty实现Dubbo多协议通信支持
#### 2.3.10 Netty无锁化串行设计及高并发处理机制

### 2.4 分布式架构实战
#### 2.4.1 分布式全局ID生成方案
#### 2.4.2 Session跨域共享及企业级单点登录解决方案实战
#### 2.4.3 分布式事务解决方案实战
#### 2.4.4 高并发下的服务降级、限流实战
#### 2.4.5 基于分布式架构下分布式锁的解决方案实战
#### 2.4.6 分布式架构下实现分布式定时调度

## 3. 性能优化
> 从JVM底层原理到内存优化，再到中间件的性能调优

### 3.1 理解性能优化
#### 3.1.1 性能基准
#### 3.1.2 性能优化到底是什么
#### 3.1.3 衡量维度

### 3.2 JVM调优
#### 3.2.1 JVM运行时数据区
#### 3.2.2 JVM内存模型 JMM
#### 3.2.3 GC可达
#### 3.2.4 各垃圾回收器使用场景(Throughput\CMS)
#### 3.2.5 GC日志，从日志看端倪
#### 3.2.6 实战MAT分析dump文件(推理、验证)

### 3.3 Tomcat调优
#### 3.3.1 Tomcat运行机制及框架
#### 3.3.2 分析Tomcat线程模型
#### 3.3.3 Tomcat系统参数认识及调优
#### 3.3.4 基准测试

### 3.4 MySQL调优
> TianZhen 20180911技术分享《统一监控平台架构和实践》，有涉及到SQL调优

#### 3.4.1 MySQL底层B+ Tree机制
#### 3.4.2 SQL执行计划详解
#### 3.4.3 索引优化详解
#### 3.4.4 SQL语句优化











